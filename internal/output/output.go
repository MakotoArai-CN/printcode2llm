package output

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"printcode2llm/internal/config"
	"printcode2llm/internal/generator"
	"printcode2llm/internal/ui"
)

func CleanOldFiles(prefix string) error {
	pattern := prefix + "*.md"
	matches, err := filepath.Glob(pattern)
	if err != nil {
		return err
	}

	for _, match := range matches {
		if err := os.Remove(match); err != nil {
			return err
		}
	}

	return nil
}

func WriteResults(results []*generator.Result, cfg *config.Config) (int64, error) {
	var allSegments []*generator.Segment

	for _, result := range results {
		allSegments = append(allSegments, result.Segments...)
	}

	totalParts := len(allSegments)
	var totalSize int64

	for i, segment := range allSegments {
		partNum := i + 1

		var filename string
		if totalParts == 1 {
			filename = fmt.Sprintf("%s.md", cfg.Output.OutputPrefix)
		} else {
			filename = fmt.Sprintf("%s_Part%d_of_%d.md", cfg.Output.OutputPrefix, partNum, totalParts)
		}

		content := segment.Content

		if totalParts > 1 {
			header := generatePartHeader(results, partNum, totalParts)
			content = header + content
		}

		if err := os.WriteFile(filename, []byte(content), 0644); err != nil {
			return totalSize, fmt.Errorf("写入 %s 失败: %w", filename, err)
		}

		fileInfo, _ := os.Stat(filename)
		size := fileInfo.Size()
		totalSize += size

		ui.PrintSuccess("已写入: %s (%s)", filename, ui.FormatBytes(size))
	}

	return totalSize, nil
}

func generatePartHeader(results []*generator.Result, partNum, totalParts int) string {
	var builder strings.Builder

	builder.WriteString("<!--\n")
	builder.WriteString("  Generated by PrintCode2LLM (ptlm)\n")

	if len(results) > 0 {
		builder.WriteString(fmt.Sprintf("  Project: %s\n", results[0].ProjectName))
	}

	builder.WriteString(fmt.Sprintf("  Part: %d of %d\n", partNum, totalParts))
	builder.WriteString("-->\n\n")

	return builder.String()
}