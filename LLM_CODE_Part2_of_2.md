<!--
  Generated by PrintCode2LLM (ptlm)
  Project: printcode2llm
  Date: 2025-11-13T19:37:12+08:00
  Part: 2 of 2
  Files: 16-24
-->

# printcode2llm (ç»­ - ç¬¬ 2 éƒ¨åˆ†)

> ğŸ“Œ **è¯´æ˜**: è¿™æ˜¯ç¬¬ 2 éƒ¨åˆ†ï¼Œç»§ç»­å±•ç¤ºé¡¹ç›®ä»£ç 

> âš ï¸ **æ³¨æ„**: æ³¨æ„ï¼šä»£ç å·²ç»è¿‡å‹ç¼©å¤„ç†ï¼Œå»ºè®®ä½¿ç”¨å‰å…ˆæ ¼å¼åŒ–ã€‚


## æºç æ¸…å•ï¼ˆç»­ï¼‰

### 16. internal/compress/compress.go

```go
package compress
import (
"fmt"
"regexp"
"strings"
"unicode"
)
var codeLanguages = map[string]bool{
"javascript": true,
"typescript": true,
"python": true,
"java": true,
"c": true,
"cpp": true,
"go": true,
"rust": true,
"php": true,
"ruby": true,
"swift": true,
"kotlin": true,
"scala": true,
"dart": true,
"csharp": true,
"objc": true,
}
var cStyleCommentLanguages = map[string]bool{
"javascript": true,
"typescript": true,
"java": true,
"c": true,
"cpp": true,
"go": true,
"rust": true,
"php": true,
"swift": true,
"kotlin": true,
"scala": true,
"dart": true,
"csharp": true,
"objc": true,
}
var pythonStyleCommentLanguages = map[string]bool{
"python": true,
"ruby": true,
"shell": true,
"bash": true,
}
func Compress(content, language string, ultraMode bool) string {
if content == "" {
return content
}
language = strings.ToLower(language)
if !codeLanguages[language] {
return basicCompress(content)
}
compressor := &Compressor{
language: language,
ultraMode: ultraMode,
tokens: make([]string, 0),
}
return compressor.Compress(content)
}
type Compressor struct {
language string
ultraMode bool
tokens []string
}
func (c *Compressor) Compress(content string) string {
content = c.protectStrings(content)
content = c.removeComments(content)
content = c.cleanWhitespace(content)
if c.ultraMode {
content = c.ultraCompress(content)
} else {
content = c.standardCompress(content)
}
content = c.restoreTokens(content)
content = c.finalCleanup(content)
return strings.TrimSpace(content)
}
func basicCompress(content string) string {
lines := strings.Split(content, "\n")
result := make([]string, 0, len(lines))
for _, line := range lines {
trimmed := strings.TrimSpace(line)
if trimmed != "" {
result = append(result, strings.TrimRight(line, " \t"))
}
}
return strings.Join(result, "\n")
}
func (c *Compressor) protectStrings(content string) string {
content = c.protectPattern(content, `"(?:[^"\\]|\\.)*"`)

	// ä¿æŠ¤å•å¼•å·å­—ç¬¦ä¸²
	content = c.protectPattern(content, `'(?:[^'\\]|\\.)*'`)

	// ä¿æŠ¤åå¼•å·å­—ç¬¦ä¸²ï¼ˆæ¨¡æ¿å­—ç¬¦ä¸²ï¼‰
	if c.language == "javascript" || c.language == "typescript" {
		content = c.protectPattern(content, "`(?:[^`\\\\]|\\\\.)*`")
	}

	// ä¿æŠ¤æ­£åˆ™è¡¨è¾¾å¼ï¼ˆJavaScript/TypeScriptï¼‰
	if c.language == "javascript" || c.language == "typescript" {
		content = c.protectRegex(content)
	}

	// ä¿æŠ¤ Python çš„ä¸‰å¼•å·å­—ç¬¦ä¸²
	if c.language == "python" {
		content = c.protectPattern(content, `"""(?:[^\\]|\\.)*?"""`)
		content = c.protectPattern(content, `'''(?:[^\\]|\\.)*?'''`)
	}

	// ä¿æŠ¤ Go çš„åŸå§‹å­—ç¬¦ä¸²
	if c.language == "go" {
		content = c.protectPattern(content, "`[^`]*`")
	}

	return content
}

// protectPattern ä¿æŠ¤åŒ¹é…çš„æ¨¡å¼
func (c *Compressor) protectPattern(content, pattern string) string {
	re := regexp.MustCompile(pattern)
	content = re.ReplaceAllStringFunc(content, func(match string) string {
		token := c.createToken()
		c.tokens = append(c.tokens, match)
		return token
	})
	return content
}

// protectRegex ä¿æŠ¤ JavaScript/TypeScript çš„æ­£åˆ™è¡¨è¾¾å¼
func (c *Compressor) protectRegex(content string) string {
	// åŒ¹é…æ­£åˆ™è¡¨è¾¾å¼å­—é¢é‡ï¼š/pattern/flags
	// éœ€è¦åŒºåˆ†é™¤æ³•è¿ç®—ç¬¦å’Œæ­£åˆ™è¡¨è¾¾å¼
	re := regexp.MustCompile(`(?:^|[=([,;:!&|?{}\n])\s*/(?![*/])(?:[^\\/\n]|\\.)+/[gimsuvy]*`)

	content = re.ReplaceAllStringFunc(content, func(match string) string {
		// æå–å‰ç¼€
		prefix := ""
		regexPart := match

		// æ‰¾åˆ°æ­£åˆ™è¡¨è¾¾å¼çš„å¼€å§‹ä½ç½®
		idx := strings.LastIndex(match, "/")
		if idx > 0 {
			for i := idx - 1; i >= 0; i-- {
				if match[i] == '/' {
					prefix = match[:i]
					regexPart = match[i:]
					break
				}
			}
		}

		// ä¿æŠ¤æ­£åˆ™è¡¨è¾¾å¼éƒ¨åˆ†
		token := c.createToken()
		c.tokens = append(c.tokens, regexPart)

		return prefix + token
	})

	return content
}

// createToken åˆ›å»ºå ä½ç¬¦
func (c *Compressor) createToken() string {
	return "___TOKEN_" + strings.Repeat("X", len(c.tokens)) + "___"
}

// restoreTokens æ¢å¤æ‰€æœ‰ token
func (c *Compressor) restoreTokens(content string) string {
	for i := len(c.tokens) - 1; i >= 0; i-- {
		token := "___TOKEN_" + strings.Repeat("X", i) + "___"
		content = strings.ReplaceAll(content, token, c.tokens[i])
	}
	return content
}

// removeComments ç§»é™¤æ³¨é‡Š
func (c *Compressor) removeComments(content string) string {
	if cStyleCommentLanguages[c.language] {
		return c.removeCStyleComments(content)
	}

	if pythonStyleCommentLanguages[c.language] {
		return c.removePythonStyleComments(content)
	}

	return content
}

// removeCStyleComments ç§»é™¤ C é£æ ¼æ³¨é‡Š
func (c *Compressor) removeCStyleComments(content string) string {
	// ç§»é™¤å•è¡Œæ³¨é‡Š //
	lines := strings.Split(content, "\n")
	for i, line := range lines {
		if idx := strings.Index(line, "//"); idx != -1 {
			lines[i] = line[:idx]
		}
	}
	content = strings.Join(lines, "\n")

	// ç§»é™¤å¤šè¡Œæ³¨é‡Š /* */
	re := regexp.MustCompile(`/\*[\s\S]*?\*/`)
	content = re.ReplaceAllString(content, "")

	return content
}

// removePythonStyleComments ç§»é™¤ Python é£æ ¼æ³¨é‡Š
func (c *Compressor) removePythonStyleComments(content string) string {
	lines := strings.Split(content, "\n")
	result := make([]string, 0, len(lines))

	for _, line := range lines {
		// æŸ¥æ‰¾ # æ³¨é‡Š
		if idx := strings.Index(line, "#"); idx != -1 {
			// ç¡®ä¿ä¸æ˜¯å­—ç¬¦ä¸²ä¸­çš„ #
			beforeHash := line[:idx]
			// ç®€å•æ£€æŸ¥ï¼šå¦‚æœ # å‰é¢æœ‰æœªé—­åˆçš„å¼•å·ï¼Œåˆ™ä¸æ˜¯æ³¨é‡Š
			singleQuotes := strings.Count(beforeHash, "'") - strings.Count(beforeHash, "\\'")
			doubleQuotes := strings.Count(beforeHash, "\"") - strings.Count(beforeHash, "\\\"")

			if singleQuotes%2 == 0 && doubleQuotes%2 == 0 {
				line = beforeHash
			}
		}

		trimmed := strings.TrimSpace(line)
		if trimmed != "" {
			result = append(result, line)
		}
	}

	return strings.Join(result, "\n")
}

// cleanWhitespace æ¸…ç†ç©ºç™½å­—ç¬¦
func (c *Compressor) cleanWhitespace(content string) string {
	lines := strings.Split(content, "\n")
	result := make([]string, 0, len(lines))

	for _, line := range lines {
		// ç§»é™¤è¡Œé¦–ç©ºæ ¼
		trimmed := strings.TrimSpace(line)

		// è·³è¿‡ç©ºè¡Œ
		if trimmed == "" {
			continue
		}

		// å‹ç¼©è¿ç»­ç©ºæ ¼ä¸ºå•ä¸ªç©ºæ ¼
		trimmed = c.compressSpaces(trimmed)

		result = append(result, trimmed)
	}

	return strings.Join(result, "\n")
}

// compressSpaces å‹ç¼©è¿ç»­ç©ºæ ¼
func (c *Compressor) compressSpaces(s string) string {
	var result strings.Builder
	var prevSpace bool

	for _, ch := range s {
		if unicode.IsSpace(ch) {
			if !prevSpace {
				result.WriteRune(' ')
				prevSpace = true
			}
		} else {
			result.WriteRune(ch)
			prevSpace = false
		}
	}

	return result.String()
}

// standardCompress æ ‡å‡†å‹ç¼©
func (c *Compressor) standardCompress(content string) string {
	// åˆå¹¶æŸäº›å¯ä»¥å®‰å…¨åˆå¹¶çš„è¡Œ
	replacements := []struct {
		pattern     string
		replacement string
	}{
		{`\n\s*\{`, " {"},                    // å°†ç‹¬ç«‹çš„ { åˆå¹¶åˆ°ä¸Šä¸€è¡Œ
		{`\}\s*\n\s*else`, "} else"},         // } else
		{`\}\s*\n\s*catch`, "} catch"},       // } catch
		{`\}\s*\n\s*finally`, "} finally"},   // } finally
		{`\}\s*\n\s*elif`, "} elif"},         // } elif (Python)
		{`\}\s*\n\s*except`, "} except"},     // } except (Python)
	}

	for _, r := range replacements {
		re := regexp.MustCompile(r.pattern)
		content = re.ReplaceAllString(content, r.replacement)
	}

	// ç§»é™¤å—ç»“æŸåçš„å¤šä½™æ¢è¡Œ
	content = regexp.MustCompile(`\n{3,}`).ReplaceAllString(content, "\n\n")

	return content
}

// ultraCompress è¶…çº§å‹ç¼©
func (c *Compressor) ultraCompress(content string) string {
	// é¦–å…ˆåº”ç”¨æ ‡å‡†å‹ç¼©
	content = c.standardCompress(content)

	// æ›´æ¿€è¿›çš„å‹ç¼©è§„åˆ™
	aggressiveReplacements := map[string]string{
		// ç§»é™¤æ‰€æœ‰æ¢è¡Œç¬¦å‘¨å›´çš„ç©ºæ ¼
		"\n{":  "{",
		"}\n":  "}",
		";\n":  ";",
		",\n":  ",",
		"{\n":  "{",
		"\n}":  "}",
		"\n;":  ";",
		"\n,":  ",",

		// ç§»é™¤æ“ä½œç¬¦å‘¨å›´çš„ç©ºæ ¼
		" {":   "{",
		" }":   "}",
		" (":   "(",
		" )":   ")",
		"( ":   "(",
		") ":   ")",
		" [":   "[",
		" ]":   "]",
		"[ ":   "[",
		"] ":   "]",
		" ;":   ";",
		" ,":   ",",
		", ":   ",",
		" :":   ":",
		": ":   ":",

		// èµ‹å€¼è¿ç®—ç¬¦
		" = ":   "=",
		" == ":  "==",
		" != ":  "!=",
		" === ": "===",
		" !== ": "!==",
		" += ":  "+=",
		" -= ":  "-=",
		" *= ":  "*=",
		" /= ":  "/=",
		" %= ":  "%=",
		" &= ":  "&=",
		" |= ":  "|=",
		" ^= ":  "^=",

		// æ¯”è¾ƒè¿ç®—ç¬¦
		" < ":  "<",
		" > ":  ">",
		" <= ": "<=",
		" >= ": ">=",

		// é€»è¾‘è¿ç®—ç¬¦
		" && ": "&&",
		" || ": "||",

		// ä½è¿ç®—ç¬¦
		" & ":  "&",
		" | ":  "|",
		" ^ ":  "^",
		" << ": "<<",
		" >> ": ">>",

		// ç®­å¤´å‡½æ•° (JavaScript/TypeScript)
		" => ": "=>",

		// Go çš„ :=
		" := ": ":=",
	}

	// åº”ç”¨æ›¿æ¢ï¼ˆå¤šæ¬¡è¿­ä»£ä»¥ç¡®ä¿å®Œå…¨å‹ç¼©ï¼‰
	maxIterations := 3
	for iteration := 0; iteration < maxIterations; iteration++ {
		changed := false
		for old, new := range aggressiveReplacements {
			if strings.Contains(content, old) {
				content = strings.ReplaceAll(content, old, new)
				changed = true
			}
		}
		if !changed {
			break
		}
	}

	// ç‰¹å®šè¯­è¨€çš„ä¼˜åŒ–
	switch c.language {
	case "javascript", "typescript":
		content = c.ultraCompressJavaScript(content)
	case "python":
		content = c.ultraCompressPython(content)
	case "go":
		content = c.ultraCompressGo(content)
	}

	// ç§»é™¤æ‰€æœ‰å¤šä½™çš„æ¢è¡Œ
	content = regexp.MustCompile(`\n+`).ReplaceAllString(content, "\n")

	return content
}

// ultraCompressJavaScript JavaScript/TypeScript ç‰¹å®šçš„è¶…çº§å‹ç¼©
func (c *Compressor) ultraCompressJavaScript(content string) string {
	// ç§»é™¤åˆ†å·åçš„æ¢è¡Œï¼ˆé™¤éä¸‹ä¸€è¡Œæ˜¯å…³é”®å­—ï¼‰
	lines := strings.Split(content, "\n")
	var result strings.Builder

	for i := 0; i < len(lines); i++ {
		line := lines[i]
		result.WriteString(line)

		// å¦‚æœè¡Œä»¥åˆ†å·ç»“å°¾ï¼Œå°è¯•åˆå¹¶ä¸‹ä¸€è¡Œ
		if strings.HasSuffix(strings.TrimSpace(line), ";") && i < len(lines)-1 {
			nextLine := strings.TrimSpace(lines[i+1])
			// æ£€æŸ¥ä¸‹ä¸€è¡Œæ˜¯å¦æ˜¯å…³é”®å­—å¼€å¤´
			if !c.startsWithKeyword(nextLine, []string{
				"import", "export", "class", "function", "const", "let", "var",
				"if", "else", "for", "while", "switch", "case", "return",
				"break", "continue", "try", "catch", "finally", "async", "await",
			}) {
				continue // ä¸æ·»åŠ æ¢è¡Œ
			}
		}

		if i < len(lines)-1 {
			result.WriteString("\n")
		}
	}

	return result.String()
}

// ultraCompressPython Python ç‰¹å®šçš„è¶…çº§å‹ç¼©
func (c *Compressor) ultraCompressPython(content string) string {
	// Python éœ€è¦ä¿ç•™ç¼©è¿›ï¼Œæ‰€ä»¥å‹ç¼©è¾ƒä¸ºä¿å®ˆ
	lines := strings.Split(content, "\n")
	result := make([]string, 0, len(lines))

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if trimmed != "" {
			// ä¿ç•™å¿…è¦çš„ç¼©è¿›ç»“æ„
			result = append(result, trimmed)
		}
	}

	return strings.Join(result, "\n")
}

// ultraCompressGo Go ç‰¹å®šçš„è¶…çº§å‹ç¼©
func (c *Compressor) ultraCompressGo(content string) string {
	// ç§»é™¤ package å’Œ import ä¹‹é—´çš„ç©ºè¡Œ
	content = regexp.MustCompile(`(package\s+\w+)\n+`).ReplaceAllString(content, "$1\n")

	// åˆå¹¶ç®€çŸ­çš„å‡½æ•°
	content = regexp.MustCompile(`\)\s*\{\s*return`).ReplaceAllString(content, "){return")

	return content
}

// startsWithKeyword æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦ä»¥å…³é”®å­—å¼€å¤´
func (c *Compressor) startsWithKeyword(s string, keywords []string) bool {
	for _, keyword := range keywords {
		if strings.HasPrefix(s, keyword) {
			// ç¡®ä¿å…³é”®å­—åé¢æ˜¯ç©ºæ ¼æˆ–å…¶ä»–éå­—æ¯å­—ç¬¦
			if len(s) == len(keyword) {
				return true
			}
			nextChar := s[len(keyword)]
			if !unicode.IsLetter(rune(nextChar)) && nextChar != '_' {
				return true
			}
		}
	}
	return false
}

// finalCleanup æœ€ç»ˆæ¸…ç†
func (c *Compressor) finalCleanup(content string) string {
	// ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„ç©ºç™½
	content = strings.TrimSpace(content)

	// ç¡®ä¿æ–‡ä»¶ä»¥æ¢è¡Œç¬¦ç»“å°¾ï¼ˆç¬¦åˆ POSIX æ ‡å‡†ï¼‰
	if !strings.HasSuffix(content, "\n") {
		content += "\n"
	}

	// ç§»é™¤è¿ç»­çš„ç©ºè¡Œï¼ˆæœ€å¤šä¿ç•™ä¸€ä¸ªï¼‰
	content = regexp.MustCompile(`\n{3,}`).ReplaceAllString(content, "\n\n")
lines := strings.Split(content, "\n")
for i, line := range lines {
lines[i] = strings.TrimRight(line, " \t")
}
content = strings.Join(lines, "\n")
return content
}
func GetCompressionStats(original, compressed string) map[string]interface{} {
stats := make(map[string]interface{})
originalSize := len(original)
compressedSize := len(compressed)
savings := originalSize - compressedSize
ratio := 0.0
if originalSize > 0 {
ratio = float64(savings) / float64(originalSize) * 100
}
originalLines := strings.Count(original, "\n") + 1
compressedLines := strings.Count(compressed, "\n") + 1
stats["original_size"] = originalSize
stats["compressed_size"] = compressedSize
stats["savings_bytes"] = savings
stats["compression_ratio"] = ratio
stats["original_lines"] = originalLines
stats["compressed_lines"] = compressedLines
stats["lines_removed"] = originalLines - compressedLines
return stats
}
func EstimateTokens(content string) int {
words := strings.Fields(content)
charCount := len(content)
tokenEstimate := (len(words) + charCount/4) / 2
return tokenEstimate
}
func ValidateCompression(original, compressed, language string) []string {
var warnings []string
if len(compressed) > len(original) {
warnings = append(warnings, "å‹ç¼©åå¤§å°å¢åŠ äº†")
}
ratio := float64(len(compressed)) / float64(len(original))
if ratio < 0.3 {
warnings = append(warnings, "å‹ç¼©ç‡è¿‡é«˜ï¼Œå¯èƒ½å½±å“å¯è¯»æ€§")
}
switch language {
case "python":
if !strings.Contains(compressed, "\n") && strings.Contains(original, "\n") {
warnings = append(warnings, "Python ä»£ç çš„æ¢è¡Œè¢«è¿‡åº¦ç§»é™¤")
}
case "go":
if strings.Contains(original, "package ") && !strings.Contains(compressed, "package ") {
warnings = append(warnings, "Go çš„ package å£°æ˜ä¸¢å¤±")
}
}
brackets := map[rune]rune{
'(': ')',
'[': ']',
'{': '}',
}
for open, close := range brackets {
openCount := strings.Count(compressed, string(open))
closeCount := strings.Count(compressed, string(close))
if openCount != closeCount {
warnings = append(warnings,
fmt.Sprintf("æ‹¬å·ä¸åŒ¹é…ï¼š%c=%d, %c=%d", open, openCount, close, closeCount))
}
}
return warnings
}
func DecompressHint(language string, ultraMode bool) string {
hints := []string{
"ä½¿ç”¨ä»£ç æ ¼å¼åŒ–å·¥å…·è¿›è¡Œæ ¼å¼åŒ–ï¼š",
}
switch language {
case "javascript", "typescript":
hints = append(hints, "  - Prettier: npx prettier --write file.js")
hints = append(hints, "  - ESLint: npx eslint --fix file.js")
case "python":
hints = append(hints, "  - Black: black file.py")
hints = append(hints, "  - autopep8: autopep8 --in-place file.py")
case "go":
hints = append(hints, "  - gofmt: gofmt -w file.go")
hints = append(hints, "  - goimports: goimports -w file.go")
case "rust":
hints = append(hints, "  - rustfmt: rustfmt file.rs")
case "java":
hints = append(hints, "  - google-java-format")
case "cpp", "c":
hints = append(hints, "  - clang-format: clang-format -i file.cpp")
}
if ultraMode {
hints = append(hints, "")
hints = append(hints, "æ³¨æ„ï¼šä½¿ç”¨äº†è¶…çº§å‹ç¼©æ¨¡å¼ï¼Œå¿…é¡»å…ˆæ ¼å¼åŒ–æ‰èƒ½æ­£å¸¸é˜…è¯»")
}
return strings.Join(hints, "\n")
}
```

### 17. internal/config/config.go

```go
package config
import (
"os"
"path/filepath"
"gopkg.in/yaml.v3"
)
type Config struct {
LanguageMap map[string]string `yaml:"language_map"`
DefaultIgnore []string `yaml:"default_ignore"`
BinaryExtensions []string `yaml:"binary_extensions"`
NonCodeExtensions []string `yaml:"non_code_extensions"`
CustomIgnore CustomIgnore `yaml:"custom_ignore"`
Output Output `yaml:"output"`
Prompts Prompts `yaml:"prompts"`
}
type CustomIgnore struct {
Patterns []string `yaml:"patterns"`
Regex []string `yaml:"regex"`
}
type Output struct {
MaxChars int `yaml:"max_chars"`
Compress bool `yaml:"compress"`
UltraCompress bool `yaml:"ultra_compress"`
SplitMode string `yaml:"split_mode"`
IncludeTree bool `yaml:"include_tree"`
OutputPrefix string `yaml:"output_prefix"`
}
type Prompts struct {
SectionInfo string `yaml:"section_info"`
SectionTree string `yaml:"section_tree"`
SectionCode string `yaml:"section_code"`
SectionStats string `yaml:"section_stats"`
HeaderPrompt string `yaml:"header_prompt"`
CompressNotice string `yaml:"compress_notice"`
UltraCompressNotice string `yaml:"ultra_compress_notice"`
ContinueNotice string `yaml:"continue_notice"`
CompleteNotice string `yaml:"complete_notice"`
ProjectSeparator string `yaml:"project_separator"`
FileInfoFormat string `yaml:"file_info_format"`
NonCodeFileNotice string `yaml:"non_code_file_notice"`
BinaryFileSkip string `yaml:"binary_file_skip"`
StatsTableHeader string `yaml:"stats_table_header"`
UsageInstructions string `yaml:"usage_instructions"`
}
var userConfigPath string
func SetConfigPath(path string) {
userConfigPath = path
}
func Load() (*Config, error) {
cfg := Default()
if userConfigPath != "" {
return LoadFrom(userConfigPath)
}
userCfgPath := ".ptlm.yaml"
if _, err := os.Stat(userCfgPath); err == nil {
userCfg, err := LoadFrom(userCfgPath)
if err != nil {
return nil, err
}
merge(cfg, userCfg)
}
return cfg, nil
}
func LoadFrom(path string) (*Config, error) {
data, err := os.ReadFile(path)
if err != nil {
return nil, err
}
var cfg Config
if err := yaml.Unmarshal(data, &cfg); err != nil {
return nil, err
}
baseCfg := Default()
merge(baseCfg, &cfg)
return baseCfg, nil
}
func Default() *Config {
cfg := &Config{
LanguageMap: make(map[string]string),
DefaultIgnore: []string{},
BinaryExtensions: []string{},
NonCodeExtensions: []string{},
CustomIgnore: CustomIgnore{
Patterns: []string{},
Regex: []string{},
},
Output: Output{
MaxChars: 50000,
Compress: true,
UltraCompress: false,
SplitMode: "file",
IncludeTree: true,
OutputPrefix: "LLM_CODE",
},
Prompts: Prompts{
SectionInfo: "é¡¹ç›®æ¦‚å†µ",
SectionTree: "ç›®å½•ç»“æ„",
SectionCode: "æºç æ¸…å•",
SectionStats: "æ•°æ®ç»Ÿè®¡",
CompressNotice: "ä»£ç å·²ç»è¿‡å‹ç¼©å¤„ç†ï¼Œå»ºè®®ä½¿ç”¨å‰å…ˆæ ¼å¼åŒ–ã€‚",
UltraCompressNotice: "ä»£ç å·²ç»è¿‡æ·±åº¦å‹ç¼©ï¼Œä½¿ç”¨å‰å¿…é¡»æ ¼å¼åŒ–ï¼Œå¦åˆ™å¯è¯»æ€§è¾ƒå·®ã€‚",
ContinueNotice: "å½“å‰å†…å®¹æœªå®Œï¼Œè¯·ç­‰å¾…åç»­éƒ¨åˆ†ã€‚",
CompleteNotice: "å…¨éƒ¨å†…å®¹å·²å±•ç¤ºå®Œæ¯•ã€‚",
FileInfoFormat: "**ç±»å‹**: %s | **è¡Œæ•°**: %d | **å¤§å°**: %s",
NonCodeFileNotice: "æ­¤æ–‡ä»¶ä¸ºé…ç½®/æ–‡æ¡£ç±»å‹ï¼Œéå¯æ‰§è¡Œä»£ç ",
BinaryFileSkip: "è·³è¿‡äºŒè¿›åˆ¶æ–‡ä»¶",
},
}
defaultPath := "configs/default.yaml"
if data, err := os.ReadFile(defaultPath); err == nil {
yaml.Unmarshal(data, cfg)
}
promptsPath := "configs/prompts.yaml"
if data, err := os.ReadFile(promptsPath); err == nil {
yaml.Unmarshal(data, &cfg.Prompts)
}
return cfg
}
func Save(cfg *Config, path string) error {
data, err := yaml.Marshal(cfg)
if err != nil {
return err
}
dir := filepath.Dir(path)
if dir != "." && dir != "" {
if err := os.MkdirAll(dir, 0755); err != nil {
return err
}
}
return os.WriteFile(path, data, 0644)
}
func merge(base, override *Config) {
if len(override.LanguageMap) > 0 {
if base.LanguageMap == nil {
base.LanguageMap = make(map[string]string)
}
for k, v := range override.LanguageMap {
base.LanguageMap[k] = v
}
}
if len(override.CustomIgnore.Patterns) > 0 {
base.CustomIgnore.Patterns = override.CustomIgnore.Patterns
}
if len(override.CustomIgnore.Regex) > 0 {
base.CustomIgnore.Regex = override.CustomIgnore.Regex
}
if override.Output.MaxChars != 0 {
base.Output.MaxChars = override.Output.MaxChars
}
if override.Output.SplitMode != "" {
base.Output.SplitMode = override.Output.SplitMode
}
if override.Output.OutputPrefix != "" {
base.Output.OutputPrefix = override.Output.OutputPrefix
}
base.Output.Compress = override.Output.Compress
base.Output.UltraCompress = override.Output.UltraCompress
base.Output.IncludeTree = override.Output.IncludeTree
if override.Prompts.HeaderPrompt != "" {
base.Prompts = override.Prompts
}
}
```

### 18. internal/generator/segment.go

```go
package generator
import (
"fmt"
"path/filepath"
"strings"
"time"
"printcode2llm/internal/compress"
"printcode2llm/internal/config"
"printcode2llm/internal/scanner"
)
type Segment struct {
Content string
StartFile int
EndFile int
HasMore bool
}
type Result struct {
ProjectName string
ProjectPath string
Segments []*Segment
FileCount int
TotalLines int
TotalChars int
CodeFiles int
ConfigFiles int
}
func Generate(projectDir string, files []*scanner.FileInfo, cfg *config.Config) (*Result, error) {
projectName := filepath.Base(projectDir)
result := &Result{
ProjectName: projectName,
ProjectPath: projectDir,
Segments: make([]*Segment, 0),
FileCount: len(files),
}
for _, file := range files {
result.TotalLines += file.LineCount
result.TotalChars += len(file.Content)
if file.IsCode {
result.CodeFiles++
} else {
result.ConfigFiles++
}
}
var currentSegment strings.Builder
currentCharCount := 0
fileCount := 1
segmentFileStart := 1
header := generateHeader(projectName, files, result, cfg)
currentSegment.WriteString(header)
currentCharCount = len(header)
if cfg.Output.IncludeTree {
tree, err := GenerateTree(projectDir, cfg)
if err == nil {
treeSection := generateTreeSection(projectName, tree, cfg)
currentSegment.WriteString(treeSection)
currentCharCount += len(treeSection)
}
}
codeHeader := generateCodeHeader(cfg)
currentSegment.WriteString(codeHeader)
currentCharCount += len(codeHeader)
for i, file := range files {
content := file.Content
if cfg.Output.Compress && file.IsCode {
content = compress.Compress(content, file.Language, cfg.Output.UltraCompress)
}
if cfg.Output.SplitMode == "line" {
if err := processFileByLine(
file,
content,
fileCount,
&currentSegment,
&currentCharCount,
&segmentFileStart,
result,
cfg,
); err != nil {
return nil, fmt.Errorf("å¤„ç†æ–‡ä»¶ %s å¤±è´¥: %w", file.RelPath, err)
}
} else {
fileBlock := generateFileBlock(fileCount, file, content, cfg)
fileBlockLen := len(fileBlock)
if currentCharCount+fileBlockLen > cfg.Output.MaxChars && currentCharCount > 0 {
continueNotice := generateContinueNotice(len(files)-i, cfg)
currentSegment.WriteString(continueNotice)
result.Segments = append(result.Segments, &Segment{
Content: currentSegment.String(),
StartFile: segmentFileStart,
EndFile: fileCount - 1,
HasMore: true,
})
currentSegment.Reset()
newHeader := generateContinuationHeader(projectName, len(result.Segments)+1, cfg)
currentSegment.WriteString(newHeader)
currentCharCount = len(newHeader)
segmentFileStart = fileCount
}
currentSegment.WriteString(fileBlock)
currentCharCount += fileBlockLen
}
fileCount++
}
if currentCharCount > 0 {
footer := generateFooter(result, cfg)
currentSegment.WriteString(footer)
result.Segments = append(result.Segments, &Segment{
Content: currentSegment.String(),
StartFile: segmentFileStart,
EndFile: fileCount - 1,
HasMore: false,
})
}
return result, nil
}
func processFileByLine(
file *scanner.FileInfo,
content string,
fileCount int,
currentSegment *strings.Builder,
currentCharCount *int,
segmentFileStart *int,
result *Result,
cfg *config.Config,
) error {
lines := strings.Split(content, "\n")
var currentFileContent strings.Builder
lineStart := 0
for j := 0; j < len(lines); j++ {
line := lines[j]
if j < len(lines)-1 {
line += "\n"
}
testLen := *currentCharCount + currentFileContent.Len() + len(line)
if testLen > cfg.Output.MaxChars && *currentCharCount > 0 {
if currentFileContent.Len() > 0 {
partialBlock := generatePartialFileBlock(
fileCount,
file,
currentFileContent.String(),
lineStart+1,
j,
cfg,
)
currentSegment.WriteString(partialBlock)
}
continueNotice := generateContinueNotice(0, cfg)
currentSegment.WriteString(continueNotice)
result.Segments = append(result.Segments, &Segment{
Content: currentSegment.String(),
StartFile: *segmentFileStart,
EndFile: fileCount,
HasMore: true,
})
currentSegment.Reset()
newHeader := generateContinuationHeader(result.ProjectName, len(result.Segments)+1, cfg)
currentSegment.WriteString(newHeader)
*currentCharCount = len(newHeader)
currentFileContent.Reset()
lineStart = j
*segmentFileStart = fileCount
}
currentFileContent.WriteString(line)
}
if currentFileContent.Len() > 0 {
var fileBlock string
if lineStart > 0 {
fileBlock = generatePartialFileBlock(
fileCount,
file,
currentFileContent.String(),
lineStart+1,
len(lines),
cfg,
)
} else {
fileBlock = generateFileBlock(fileCount, file, currentFileContent.String(), cfg)
}
currentSegment.WriteString(fileBlock)
*currentCharCount += len(fileBlock)
}
return nil
}
func generateHeader(projectName string, files []*scanner.FileInfo, result *Result, cfg *config.Config) string {
var builder strings.Builder
builder.WriteString(fmt.Sprintf("# %s\n\n", projectName))
if cfg.Prompts.HeaderPrompt != "" {
builder.WriteString(cfg.Prompts.HeaderPrompt)
builder.WriteString("\n\n")
}
builder.WriteString(fmt.Sprintf("## %s\n\n", cfg.Prompts.SectionInfo))
builder.WriteString(fmt.Sprintf("- **é¡¹ç›®åç§°**: %s\n", projectName))
builder.WriteString(fmt.Sprintf("- **ç”Ÿæˆæ—¶é—´**: %s\n", time.Now().Format("2006-01-02 15:04:05")))
builder.WriteString(fmt.Sprintf("- **æ–‡ä»¶æ€»æ•°**: %d ä¸ªï¼ˆä»£ç : %d, é…ç½®: %dï¼‰\n",
len(files), result.CodeFiles, result.ConfigFiles))
builder.WriteString(fmt.Sprintf("- **æ€»è¡Œæ•°**: %s è¡Œ\n", formatNumber(result.TotalLines)))
builder.WriteString(fmt.Sprintf("- **æ€»å­—ç¬¦æ•°**: %s å­—ç¬¦\n", formatNumber(result.TotalChars)))
if cfg.Output.Compress {
compressMode := "æ ‡å‡†å‹ç¼©"
notice := cfg.Prompts.CompressNotice
if cfg.Output.UltraCompress {
compressMode = "è¶…çº§å‹ç¼©"
notice = cfg.Prompts.UltraCompressNotice
}
builder.WriteString(fmt.Sprintf("- **å‹ç¼©æ¨¡å¼**: %s\n", compressMode))
if notice != "" {
builder.WriteString(fmt.Sprintf("\n> âš ï¸ **æ³¨æ„**: %s\n", notice))
}
}
builder.WriteString("\n")
return builder.String()
}
func generateTreeSection(projectName, tree string, cfg *config.Config) string {
var builder strings.Builder
builder.WriteString(fmt.Sprintf("## %s\n\n", cfg.Prompts.SectionTree))
builder.WriteString("```tree\n")
builder.WriteString(fmt.Sprintf("%s/\n%s", projectName, tree))
builder.WriteString("```\n\n")
return builder.String()
}
func generateCodeHeader(cfg *config.Config) string {
return fmt.Sprintf("## %s\n\n", cfg.Prompts.SectionCode)
}
func generateContinuationHeader(projectName string, partNum int, cfg *config.Config) string {
var builder strings.Builder
builder.WriteString(fmt.Sprintf("# %s (ç»­ - ç¬¬ %d éƒ¨åˆ†)\n\n", projectName, partNum))
builder.WriteString(fmt.Sprintf("> ğŸ“Œ **è¯´æ˜**: è¿™æ˜¯ç¬¬ %d éƒ¨åˆ†ï¼Œç»§ç»­å±•ç¤ºé¡¹ç›®ä»£ç \n\n", partNum))
if cfg.Output.Compress {
notice := cfg.Prompts.CompressNotice
if cfg.Output.UltraCompress {
notice = cfg.Prompts.UltraCompressNotice
}
if notice != "" {
builder.WriteString(fmt.Sprintf("> âš ï¸ **æ³¨æ„**: %s\n\n", notice))
}
}
builder.WriteString(fmt.Sprintf("## %sï¼ˆç»­ï¼‰\n\n", cfg.Prompts.SectionCode))
return builder.String()
}
func generateContinueNotice(remainingFiles int, cfg *config.Config) string {
var builder strings.Builder
builder.WriteString("\n---\n\n")
if remainingFiles > 0 {
builder.WriteString(fmt.Sprintf("> ğŸ“‹ **æç¤º**: è¿˜æœ‰ %d ä¸ªæ–‡ä»¶æœªå±•ç¤ºï¼Œå†…å®¹å°†åœ¨ä¸‹ä¸€éƒ¨åˆ†ç»§ç»­\n", remainingFiles))
} else {
builder.WriteString(fmt.Sprintf("> ğŸ“‹ **æç¤º**: %s\n", cfg.Prompts.ContinueNotice))
}
builder.WriteString("\n")
return builder.String()
}
func generateFileBlock(fileNum int, file *scanner.FileInfo, content string, cfg *config.Config) string {
var builder strings.Builder
builder.WriteString(fmt.Sprintf("### %d. %s\n\n", fileNum, file.RelPath))
if !cfg.Output.Compress {
sizeStr := formatSize(file.Size)
fileType := file.Language
if !file.IsCode {
fileType += " (é…ç½®)"
}
info := fmt.Sprintf(cfg.Prompts.FileInfoFormat, fileType, file.LineCount, sizeStr)
builder.WriteString(fmt.Sprintf("> %s\n", info))
if !file.IsCode && cfg.Prompts.NonCodeFileNotice != "" {
builder.WriteString(fmt.Sprintf("> %s\n", cfg.Prompts.NonCodeFileNotice))
}
builder.WriteString("\n")
}
builder.WriteString(fmt.Sprintf("```%s\n", file.Language))
builder.WriteString(content)
if !strings.HasSuffix(content, "\n") {
builder.WriteString("\n")
}
builder.WriteString("```\n\n")
return builder.String()
}
func generatePartialFileBlock(fileNum int, file *scanner.FileInfo, content string, lineStart, lineEnd int, cfg *config.Config) string {
var builder strings.Builder
builder.WriteString(fmt.Sprintf("### %d. %s (è¡Œ %d-%d)\n\n", fileNum, file.RelPath, lineStart, lineEnd))
if !cfg.Output.Compress {
fileType := file.Language
if !file.IsCode {
fileType += " (é…ç½®)"
}
actualLines := strings.Count(content, "\n") + 1
info := fmt.Sprintf("**ç±»å‹**: %s | **éƒ¨åˆ†**: è¡Œ %d è‡³ %d | **è¡Œæ•°**: %d",
fileType, lineStart, lineEnd, actualLines)
builder.WriteString(fmt.Sprintf("> %s\n", info))
if !file.IsCode && cfg.Prompts.NonCodeFileNotice != "" {
builder.WriteString(fmt.Sprintf("> %s\n", cfg.Prompts.NonCodeFileNotice))
}
builder.WriteString("\n")
}
builder.WriteString(fmt.Sprintf("```%s\n", file.Language))
builder.WriteString(content)
if !strings.HasSuffix(content, "\n") {
builder.WriteString("\n")
}
builder.WriteString("```\n\n")
return builder.String()
}
func generateFooter(result *Result, cfg *config.Config) string {
var builder strings.Builder
builder.WriteString("\n---\n\n")
builder.WriteString(fmt.Sprintf("## %s\n\n", cfg.Prompts.SectionStats))
if cfg.Prompts.CompleteNotice != "" {
builder.WriteString(fmt.Sprintf("âœ… **%s**\n\n", cfg.Prompts.CompleteNotice))
}
builder.WriteString("### é¡¹ç›®ç»Ÿè®¡\n\n")
builder.WriteString(cfg.Prompts.StatsTableHeader)
builder.WriteString(fmt.Sprintf("| æ–‡ä»¶æ€»æ•° | %d |\n", result.FileCount))
builder.WriteString(fmt.Sprintf("| ä»£ç æ–‡ä»¶ | %d |\n", result.CodeFiles))
builder.WriteString(fmt.Sprintf("| é…ç½®æ–‡ä»¶ | %d |\n", result.ConfigFiles))
builder.WriteString(fmt.Sprintf("| æ€»è¡Œæ•° | %s |\n", formatNumber(result.TotalLines)))
builder.WriteString(fmt.Sprintf("| æ€»å­—ç¬¦æ•° | %s |\n", formatNumber(result.TotalChars)))
if len(result.Segments) > 0 {
builder.WriteString(fmt.Sprintf("| åˆ†æ®µæ•°é‡ | %d |\n", len(result.Segments)))
}
builder.WriteString("\n")
if len(result.Segments) > 1 && cfg.Prompts.UsageInstructions != "" {
instructions := fmt.Sprintf(cfg.Prompts.UsageInstructions, len(result.Segments))
builder.WriteString(instructions)
builder.WriteString("\n")
}
return builder.String()
}
func formatSize(size int64) string {
const unit = 1024
if size < unit {
return fmt.Sprintf("%d B", size)
}
div, exp := int64(unit), 0
for n := size / unit; n >= unit; n /= unit {
div *= unit
exp++
}
return fmt.Sprintf("%.1f %cB", float64(size)/float64(div), "KMGTPE"[exp])
}
func formatNumber(n int) string {
str := fmt.Sprintf("%d", n)
if len(str) <= 3 {
return str
}
var result []byte
for i, ch := range str {
if i > 0 && (len(str)-i)%3 == 0 {
result = append(result, ',')
}
result = append(result, byte(ch))
}
return string(result)
}
```

### 19. internal/generator/tree.go

```go
package generator
import (
"os"
"path/filepath"
"sort"
"strings"
"printcode2llm/internal/config"
"printcode2llm/internal/scanner"
)
func GenerateTree(dir string, cfg *config.Config) (string, error) {
absDir, err := filepath.Abs(dir)
if err != nil {
return "", err
}
var builder strings.Builder
ignoreChecker := scanner.NewIgnoreChecker(cfg)
err = generateTreeRecursive(absDir, "", &builder, ignoreChecker, true)
if err != nil {
return "", err
}
return builder.String(), nil
}
func generateTreeRecursive(dir, prefix string, builder *strings.Builder, ignoreChecker *scanner.IgnoreChecker, isRoot bool) error {
entries, err := os.ReadDir(dir)
if err != nil {
return err
}
var validEntries []os.DirEntry
for _, entry := range entries {
path := filepath.Join(dir, entry.Name())
if !ignoreChecker.ShouldIgnore(path, entry.IsDir()) {
validEntries = append(validEntries, entry)
}
}
sort.Slice(validEntries, func(i, j int) bool {
if validEntries[i].IsDir() != validEntries[j].IsDir() {
return validEntries[i].IsDir()
}
return validEntries[i].Name() < validEntries[j].Name()
})
for i, entry := range validEntries {
isLast := i == len(validEntries)-1
connector := "â”œâ”€â”€ "
if isLast {
connector = "â””â”€â”€ "
}
name := entry.Name()
if entry.IsDir() {
name += "/"
}
if !isRoot || i > 0 {
builder.WriteString(prefix)
}
builder.WriteString(connector)
builder.WriteString(name)
builder.WriteString("\n")
if entry.IsDir() {
nextPrefix := prefix
if isLast {
nextPrefix += "    "
} else {
nextPrefix += "â”‚   "
}
subDir := filepath.Join(dir, entry.Name())
if err := generateTreeRecursive(subDir, nextPrefix, builder, ignoreChecker, false); err != nil {
return err
}
}
}
return nil
}
```

### 20. internal/scanner/ignore.go

```go
package scanner
import (
"path/filepath"
"regexp"
"strings"
"printcode2llm/internal/config"
)
type IgnoreChecker struct {
patterns []string
regexList []*regexp.Regexp
cfg *config.Config
}
func NewIgnoreChecker(cfg *config.Config) *IgnoreChecker {
checker := &IgnoreChecker{
patterns: make([]string, 0),
regexList: make([]*regexp.Regexp, 0),
cfg: cfg,
}
checker.patterns = append(checker.patterns, cfg.DefaultIgnore...)
checker.patterns = append(checker.patterns, cfg.CustomIgnore.Patterns...)
for _, regexStr := range cfg.CustomIgnore.Regex {
if re, err := regexp.Compile(regexStr); err == nil {
checker.regexList = append(checker.regexList, re)
}
}
return checker
}
func (ic *IgnoreChecker) ShouldIgnore(path string, isDir bool) bool {
name := filepath.Base(path)
cleanPath := filepath.ToSlash(path)
for _, pattern := range ic.patterns {
if strings.Contains(pattern, "*") || strings.Contains(pattern, "?") {
matched, _ := filepath.Match(pattern, name)
if matched {
return true
}
matched, _ = filepath.Match(pattern, cleanPath)
if matched {
return true
}
} else {
if name == pattern {
return true
}
if strings.Contains(cleanPath, pattern) {
return true
}
}
}
for _, re := range ic.regexList {
if re.MatchString(cleanPath) || re.MatchString(name) {
return true
}
}
return false
}
```

### 21. internal/scanner/scanner.go

```go
package scanner
import (
"bytes"
"fmt"
"os"
"path/filepath"
"sort"
"strings"
"unicode/utf8"
"printcode2llm/internal/config"
)
type FileInfo struct {
Path string
RelPath string
Language string
Content string
IsCode bool
IsBinary bool
HasNewline bool
LineCount int
Size int64
Encoding string
}
func ScanDirectory(dir string, cfg *config.Config) ([]*FileInfo, error) {
absDir, err := filepath.Abs(dir)
if err != nil {
return nil, fmt.Errorf("è·å–ç»å¯¹è·¯å¾„å¤±è´¥: %w", err)
}
var files []*FileInfo
ignoreChecker := NewIgnoreChecker(cfg)
err = filepath.Walk(absDir, func(path string, info os.FileInfo, err error) error {
if err != nil {
return nil
}
relPath, err := filepath.Rel(absDir, path)
if err != nil {
return nil
}
if relPath == "." {
return nil
}
if ignoreChecker.ShouldIgnore(path, info.IsDir()) {
if info.IsDir() {
return filepath.SkipDir
}
return nil
}
if info.IsDir() {
return nil
}
if info.Size() > 10*1024*1024 {
return nil
}
if isBinaryExtension(path, cfg) {
return nil
}
content, err := os.ReadFile(path)
if err != nil {
return nil
}
if isBinaryContent(content) {
return nil
}
contentStr := string(content)
encoding := detectEncoding(content)
hasNewline := detectNewline(contentStr)
ext := strings.ToLower(filepath.Ext(path))
language := cfg.LanguageMap[ext]
if language == "" {
language = "text"
}
isCode := !isNonCodeFile(ext, cfg)
lineCount := countLines(contentStr)
files = append(files, &FileInfo{
Path: path,
RelPath: filepath.ToSlash(relPath),
Language: language,
Content: contentStr,
IsCode: isCode,
IsBinary: false,
HasNewline: hasNewline,
LineCount: lineCount,
Size: info.Size(),
Encoding: encoding,
})
return nil
})
if err != nil {
return nil, fmt.Errorf("æ‰«æç›®å½•å¤±è´¥: %w", err)
}
sort.Slice(files, func(i, j int) bool {
return files[i].RelPath < files[j].RelPath
})
return files, nil
}
func isBinaryExtension(path string, cfg *config.Config) bool {
ext := strings.ToLower(filepath.Ext(path))
for _, binExt := range cfg.BinaryExtensions {
if ext == binExt {
return true
}
}
return false
}
func isBinaryContent(content []byte) bool {
if len(content) == 0 {
return false
}
sampleSize := 8192
if len(content) < sampleSize {
sampleSize = len(content)
}
sample := content[:sampleSize]
if bytes.IndexByte(sample, 0) != -1 {
return true
}
if !utf8.Valid(sample) {
return true
}
nonPrintable := 0
for _, b := range sample {
if b < 32 && b != '\t' && b != '\n' && b != '\r' {
nonPrintable++
}
if b == 127 {
nonPrintable++
}
}
if float64(nonPrintable)/float64(len(sample)) > 0.3 {
return true
}
return false
}
func detectEncoding(content []byte) string {
if len(content) >= 3 {
if content[0] == 0xEF && content[1] == 0xBB && content[2] == 0xBF {
return "UTF-8 with BOM"
}
}
if len(content) >= 2 {
if content[0] == 0xFF && content[1] == 0xFE {
return "UTF-16 LE"
}
if content[0] == 0xFE && content[1] == 0xFF {
return "UTF-16 BE"
}
}
if utf8.Valid(content) {
return "UTF-8"
}
return "Unknown"
}
func detectNewline(content string) bool {
return strings.Contains(content, "\n") ||
strings.Contains(content, "\r\n") ||
strings.Contains(content, "\r")
}
func getNewlineType(content string) string {
hasCRLF := strings.Contains(content, "\r\n")
hasLF := strings.Contains(content, "\n")
hasCR := strings.Contains(content, "\r")
if hasCRLF {
return "CRLF (Windows)"
} else if hasLF {
return "LF (Unix)"
} else if hasCR {
return "CR (Old Mac)"
}
return "None"
}
func isNonCodeFile(ext string, cfg *config.Config) bool {
for _, nonCodeExt := range cfg.NonCodeExtensions {
if ext == nonCodeExt {
return true
}
}
return false
}
func countLines(content string) int {
if content == "" {
return 0
}
content = strings.ReplaceAll(content, "\r\n", "\n")
content = strings.ReplaceAll(content, "\r", "\n")
count := 1
for _, ch := range content {
if ch == '\n' {
count++
}
}
if strings.HasSuffix(content, "\n") {
count--
}
if count < 1 {
count = 1
}
return count
}
func ValidateContent(file *FileInfo) []string {
var warnings []string
if len(file.Content) == 0 {
warnings = append(warnings, "æ–‡ä»¶ä¸ºç©º")
return warnings
}
if !file.HasNewline && file.Size > 0 {
warnings = append(warnings, "æ–‡ä»¶ä¸åŒ…å«æ¢è¡Œç¬¦")
}
hasCRLF := strings.Contains(file.Content, "\r\n")
hasLF := strings.Contains(file.Content, "\n")
hasCR := strings.Contains(file.Content, "\r")
mixedNewlines := 0
if hasCRLF {
mixedNewlines++
}
if hasLF && !hasCRLF {
mixedNewlines++
}
if hasCR && !hasCRLF {
mixedNewlines++
}
if mixedNewlines > 1 {
warnings = append(warnings, "æ–‡ä»¶åŒ…å«æ··åˆçš„æ¢è¡Œç¬¦ç±»å‹")
}
lines := strings.Split(file.Content, "\n")
trailingSpaceLines := 0
for _, line := range lines {
if len(line) > 0 && (line[len(line)-1] == ' ' || line[len(line)-1] == '\t') {
trailingSpaceLines++
}
}
if trailingSpaceLines > 0 {
warnings = append(warnings,
fmt.Sprintf("æœ‰ %d è¡ŒåŒ…å«è¡Œå°¾ç©ºæ ¼", trailingSpaceLines))
}
if !strings.HasSuffix(file.Content, "\n") {
warnings = append(warnings, "æ–‡ä»¶ä¸ä»¥æ¢è¡Œç¬¦ç»“å°¾")
}
maxLineLength := 0
for _, line := range lines {
if len(line) > maxLineLength {
maxLineLength = len(line)
}
}
if maxLineLength > 500 {
warnings = append(warnings,
fmt.Sprintf("åŒ…å«è¶…é•¿è¡Œï¼ˆæœ€é•¿ %d å­—ç¬¦ï¼‰", maxLineLength))
}
if strings.Contains(file.Content, "\t") {
tabCount := strings.Count(file.Content, "\t")
warnings = append(warnings,
fmt.Sprintf("åŒ…å« %d ä¸ª Tab å­—ç¬¦", tabCount))
}
return warnings
}
func GetFileStats(files []*FileInfo) map[string]interface{} {
stats := make(map[string]interface{})
totalFiles := len(files)
totalLines := 0
totalSize := int64(0)
codeFiles := 0
configFiles := 0
languageCount := make(map[string]int)
encodingCount := make(map[string]int)
for _, file := range files {
totalLines += file.LineCount
totalSize += file.Size
if file.IsCode {
codeFiles++
} else {
configFiles++
}
languageCount[file.Language]++
encodingCount[file.Encoding]++
}
stats["total_files"] = totalFiles
stats["total_lines"] = totalLines
stats["total_size"] = totalSize
stats["code_files"] = codeFiles
stats["config_files"] = configFiles
stats["language_count"] = languageCount
stats["encoding_count"] = encodingCount
return stats
}
```

### 22. internal/ui/banner.go

```go
package ui
import (
"fmt"
)
func PrintBanner() {
banner := `
    ___       _   _             ____   _     _     __  __
   / _  _ __(_)_| |_ _ __     |___  | |   | |   |  /  |
  / /_)/ '__| | ' _| '_  _____  __) || |   | |   | |/| |
 / ___/| |  | | | | | | | |_____/ __/ | |___| |___| |  | |
 /    |_|  |_|_| |_| |_|      |_____|_____|_____|_|  |_|

            ä»£ç æ•´ç†å·¥å…· Â· Miku Edition
`
colorCyan.Print(banner)
colorPink.Println("            â™« è®©ä»£ç ä¼ é€’ç»™ AI æ›´è½»æ¾ â™«")
fmt.Println()
}
```

### 23. internal/ui/color.go

```go
package ui
import (
"fmt"
"strings"
"github.com/fatih/color"
)
var (
colorCyan = color.New(color.FgCyan, color.Bold)
colorPink = color.New(color.FgHiMagenta, color.Bold)
colorGreen = color.New(color.FgGreen, color.Bold)
colorRed = color.New(color.FgRed, color.Bold)
colorYellow = color.New(color.FgYellow)
colorWhite = color.New(color.FgWhite)
colorBlue = color.New(color.FgBlue, color.Bold)
)
func PrintHeader(text string) {
fmt.Println()
colorCyan.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
textLen := len([]rune(text))
lineLen := 40
padding := (lineLen - textLen) / 2
if padding < 0 {
padding = 0
}
fmt.Print(strings.Repeat(" ", padding))
colorPink.Printf("%s", text)
fmt.Println()
colorCyan.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
fmt.Println()
}
func PrintSection(format string, args ...interface{}) {
colorBlue.Printf("â–¸ "+format+"\n", args...)
}
func PrintInfo(format string, args ...interface{}) {
colorCyan.Printf("  â„¹ "+format+"\n", args...)
}
func PrintSuccess(format string, args ...interface{}) {
colorGreen.Printf("  âœ“ "+format+"\n", args...)
}
func PrintWarning(format string, args ...interface{}) {
colorYellow.Printf("  âš  "+format+"\n", args...)
}
func PrintError(format string, args ...interface{}) {
colorRed.Printf("  âœ— "+format+"\n", args...)
}
func PrintStep(format string, args ...interface{}) {
colorWhite.Printf("  â†’ "+format+"\n", args...)
}
func FormatNumber(n int) string {
str := fmt.Sprintf("%d", n)
if len(str) <= 3 {
return str
}
var result []byte
for i, ch := range str {
if i > 0 && (len(str)-i)%3 == 0 {
result = append(result, ',')
}
result = append(result, byte(ch))
}
return string(result)
}
func FormatBytes(size int64) string {
const unit = 1024
if size < unit {
return fmt.Sprintf("%d B", size)
}
div, exp := int64(unit), 0
for n := size / unit; n >= unit; n /= unit {
div *= unit
exp++
}
return fmt.Sprintf("%.2f %cB", float64(size)/float64(div), "KMGTPE"[exp])
}
```

### 24. internal/version/version.go

```go
package version
const (
Version = "1.0.0"
Author = "PrintCode2LLM"
Repo = "https://github.com/MakotoArai-CN/printcode2llm"
)
```


---

## æ•°æ®ç»Ÿè®¡

âœ… **å…¨éƒ¨å†…å®¹å·²å±•ç¤ºå®Œæ¯•ã€‚
**

### é¡¹ç›®ç»Ÿè®¡

| æŒ‡æ ‡ | æ•°å€¼ |
|------|------|
| æ–‡ä»¶æ€»æ•° | 24 |
| ä»£ç æ–‡ä»¶ | 20 |
| é…ç½®æ–‡ä»¶ | 4 |
| æ€»è¡Œæ•° | 4,124 |
| æ€»å­—ç¬¦æ•° | 95,757 |
| åˆ†æ®µæ•°é‡ | 1 |

